========= Basic =========
- CA - Certificate authority: Web browsers comes with pre-installed list of CAs (Trusted Root CA store) that it trusts. All the certificates orginated from any of these CAs are thus also trusted by the browsers.
- Essentially, three keys are used to set up the SSL connection: the public, private, and session keys. Anything encrypted with the public key can only be decrypted with the private key, and vice versa. Because, encrypting and decrypting with private and public key takes a lot of processing power, they are only used during the SSL Handshake to create a symmetric session key. After the secure connection is made, the session key is used to encrypt all transmitted data.
	- Server sends a copy of its SSL Certificate, including the server’s public key.
	- Browser checks the certificate root against a list of trusted CAs and that the certificate is unexpired, unrevoked, and that its common name is valid for the website that it is connecting to. If the browser trusts the certificate, it creates, encrypts, and sends back a symmetric session key using the server’s public key. 
	- Server decrypts the symmetric session key using its private key and sends back an acknowledgement encrypted with the session key to start the encrypted session
	- Server and Browser now encrypt all transmitted data with the session key. 
- Asymmetric encryption (or public-key cryptography) uses a separate key for encryption and decryption. Anyone can use the encryption key (public key) to encrypt a message. However, decryption keys (private keys) are secret. This way only the intended receiver can decrypt the message. The most common asymmetric encryption algorithm is RSA
- Symmetric encryption (or pre-shared key encryption) uses a single key to both encrypt and decrypt data. Both the sender and the receiver need the same key to communicate.
- A CSR is an encoded file that provides you with a standardized way to send CA (like DigiCert) your public key as well as some information that identifies your company and domain name. The CSR data file that you send to the SSL Certificate issuer (called a Certificate Authority or CA) contains the public key. The CA uses the CSR data file to create a data structure to match your private key without compromising the key itself. The CA never sees the private key.  The certificate created with a particular CSR will only work with the private key that was generated with it. So if you lose the private key, the certificate will no longer work.  CSR also contains the public key that will be included in your certificate and is signed with the corresponding private key.
- Standard SSL certficate is issued after verifying domain, name, and few more details, where as EV (Extended Value) SSL certificate is issued after a relatively strict verification (even adress). Thus EV secured websites can be considered highly trusted. In case of EV trusted website, the adress bar itself shows a name at right end of the bar.
- Most CSRs are created in the Base-64 encoded PEM format. This format includes the "-----BEGIN CERTIFICATE REQUEST-----" and "-----END CERTIFICATE REQUEST-----" lines at the begining and end of the CSR. You need to generate a CSR and private key on the server that the certificate will be used on.
- In Nginx or any server component, we configure SSL certficate (issues by CA) and SSL key (private key). We do not need to configure public key anywhere, as SSL certficate already contains the public key. While storing, most of the system uses the string boundary such as "--BEGIN CERTIFICATE REQUEST--", "--BEGIN CERTIFICATE--" , "--BEGIN PRIVATE KEY--"
- the certficates and keys can be stored in arious format like .pem, .cer, .der, .crt etc
- PEM files: In effect PEM just means the file contains a base64-encoded bit of data. Typically a PEM file contains a base64 encoded key or certificate with header and footer lines of the form -----BEGIN <whatever>----- and -----END <whatever>----.
- You can check the details of a .pem file with "openssl x509 -in cert.pem -text -noout"
- DER file will have keys in its raw format, where as PEM file store base64 encoded content. DER content can be checked by "openssl x509   -inform DER -in cert.der" . 
- Certificate Authorities do not issue server/leaf certificates (end user SSL certificates) directly off of their roots. Those roots are too valuable and there’s just too much risk. 
- CAs do not issue directly from their roots. They add layers of security by issuing intermediates and then signing certificates with those. This helps to minimize and compartmentalize damage in the event of a mis-issuance or security event. Rather than revoke the root certificate and literally every certificate that it signed by extension, you just revoke the intermediate, which only causes the group of certificates issued off that intermediate to get distrusted.
- In SSL/TLS, asymmetric encryption serves one, extremely important function. It lets the client encrypt the data that will be used by both parties to derive the symmetric session keys they’ll use to communicate. You could never use asymmetric encryption to functionally communicate. While the public key can be used to verify a digital signature, it can’t outright decrypt anything that the private key encrypts, hence we call asymmetric encryption “one way.”
- https://www.thesslstore.com/blog/what-is-256-bit-encryption/
- Hashing is the practice of using an algorithm to map data of any size to a fixed length... Its a one way process, which means you can create a hash of a string, but you can not get the original string based on its hash value.. This is quite obvious, as the original string can be of any length and thus infinite, where as any hashing algorithm leads to a fixed length output, thus leading to a finite (quite large but finite) number of possibility. So, there can not be a one-to-one mapping between possible strings and possible hashes. Multiple strings could possibly lead to same hash (this is reffered as collision), however finding such two strings is extremely difficult.
- An SSL certificate contains: Common Name (CN), other relevant details of the organisation; public key; CN of CA; digital signature of CA ; expiry/validity details
- HTTPS only ensures that data exchange between you and the server can not be stolen by MITM attackers. However, it does not guarantee how good/bad server is... it also does not prevent you from getting viruses... it also doesnot protect your device from being hacked.
- .der => The parent format of PEM. It's useful to think of it as a binary version of the base64-encoded PEM file.
- .pem => ".pem" files may contain public, private or public+private keys in .pem format. A .pem file is just a Base64 encoded .der file. If the file's content begins with -----BEGIN and you can read it in a text editor (ASCII format), that means its mostly in .pem format.
- .key => ".key" is just a convention and not a format. ".key" files are a convention to store private keys in mostly .pem format. 
- .pkcs12 .pfx .p12 => these "12" variant is a passworded container format that contains both public and private certificate pairs. Unlike .pem files, this container is fully encrypted. Openssl can turn this into a .pem file with both public and private keys: "openssl pkcs12 -in file-to-convert.p12 -out converted-file.pem -nodes" 


========= Q&A ==========
- why intermediate certificate? why not directly signed by CA root? => to compartmentalise the damage in case of bad job done while issuing certficates
- You need to generate a CSR and private key on the server that the certificate will be used on. why? => not really needed.. it simply means that, the private & public key must be generated by the owners.. One advantage to generating them on the server in question is it minimises the chance of the key being compromised in transit
- I can conect to a server, send any data, get the corresponding encrypted data (using public key).. now I can work on this encrypted data to get the original data through hit and trial.. as soon as I decrypt it, means I have the private key.. this we can do out-of-session on our own time, so effectivel a super computer can certainly get private certificate of any server?? => Yes, one can do so, however even considering the average number of trials, it would take billion years for even supercomputers to guess a 256 bits key
- how data remain encryted on channel? if its encypted with public key only, then only server can decrypt it - what about communication from server to client? moreover, for a communication from server to client, any thrid party can peep in, as he also has the same public key? => aysymmetric encryption is always one-way (client to server) and is used to establish a common symmetric key for a session
- hashing vs encryption? => encryption is a two way function, which means we encrypt a string only with an intention for it to be decrypted sometime. However, hashing is one way, and is mainly used for checksum/string-equality
- can a proxy server read all my https traffic?? => normally not but yes if the machine you are working on has been pre-installed with their self-signed certificates (this could happen if you are connecting from a company network+m/c and the corresponding browser already has the self-signed certificates pre-installed on them.. for this they would be using SSL termination at proxy level and managing SSL channel for both sides)
- symmetric vs asymmetric keys ?? => Symmetric implies that both party has same key, and this same key is used for both (secryption/decryption). However, in case of assyemetric client will have public key where as server will have private keys. In HTTPS, the initial handshake happens using asymmetric keys.. post that, client generate a random key and encrypts it using server's public key.. server decrypts the message using its private key to find the original key (generated by client).. all the following communication, uses this common key for encryption and decryption.
- why something encrypted with public key gets decrypted with its private key? whats so fascinating relationship between public and private part that can not be easily guessed but works perfectly? => both the public and private keys are computed together at the same time, in the same mathematical process. This means they’re strongly related, mathematically speaking. Because of this relationship, they can be used to encrypt/decrypt the same data. And that is also why public and private keys from different key-pairs would not work together... When very large prime numbers are multiplied together, they’re essentially impossible to factor (“unmultiply”) without knowing what the original numbers were. It’s not magic, it just happens to be the way the math works with prime numbers.
- how does cloudflare generates certificate that browser trusts for accessing any website? => the certficate that it generates are signed by one of the CA (AddTrust - included in trusted root CA store of browser) and has name of the website as one of the entry in its "Subject Alt Names" field. Thats why its trusted by the browser.
- what does it mean to install a certficate on server? => Server first generates a pair of private & public key. Using public key, CSR is created (in many instance, you directly get to create the pair of private key & CSR - as CSR would anyway have public key). The CSR is then sent to CA for getting a SSL certficate. Once you get the SSL certficate, you need to configure your server so that your web-app knows where your SSL certficate and private key is. This process of configuration is installation.
- does public wi-fi poses any security threat? => yes, it does.. any non-ssl connection packets can easily be read by MITM.. if somehow you use their device as well (within their network), they can read all the SSL packets as well by using SSL termination.. apart from this your device is always susceptible to malware & file-theft (if not protected properly)
- PKI (Public Key Infrastructure) => A public key infrastructure (PKI) is a set sytem and procedures needed to manage public-key encryption. The purpose of a PKI is to facilitate the secure electronic transfer of information for a range of network activities.
- AES vs RSA ? => Both are encryption/decryption algorithm. AES uses symmetric keys, where as RSA works with asymmetric keys (PS: the last letter of both could help you remmber this difference). AES is really fast, but suffers from the security risks of key exchange which can be solved using RSA. Thus https connection uses asymetric keys (and alogorithm like RSA) to exchange/share a symmetric key, and after that it uses that symmetric key (and alogorithm like AES) for all the purpose.